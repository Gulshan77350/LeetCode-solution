INTUITION:
âœ… Intuition Behind the Solution

The problem being solved here is:

Count number of substrings where
#ones â‰¥ (#zeros)Â²

This is a hard constraint because:

zeros contribute quadratically,

substring lengths vary,

brute force (O(nÂ²)) is impossible.

This solution uses a mathematical + two-pointer + gap-based optimization.

ğŸ” Key Ideas
1. Preprocess all positions of zeros

We store all indexes of '0' in pos[].

Example:
s = 11010110
pos = [-1, 2, 4, 6, n]

This lets us treat substrings by the zeros they include, instead of raw indices.

2. Substrings with zero zeros (all '1's)

Any continuous block of ones of size k contains:

k*(k+1)/2 substrings


So for every pair (pos[i-1], pos[i]), the ones-only gap is computed and added.

3. For substrings with z â‰¥ 1 zeros

Everything becomes trickier.

Main Observation

If a substring contains z zeros, it must have:

length â‰¥ zÂ² + z


Why?

Because:

#ones â‰¥ zÂ²
length = #ones + z  â‰¥ zÂ² + z


So for each group of z consecutive zeros, we only need to count substring start-end pairs that satisfy this minimum length.

4. Considering each block of z consecutive zeros

Let the group of zero positions be:

pos[a], pos[a+1], ..., pos[a+z-1]


The substring:

may start anywhere between pos[a-1] + 1 and pos[a]

may end anywhere between pos[a+z-1] and pos[a+z] - 1

These define:

left range = positions before first zero

right range = positions after last zero

Both regions are continuous 1-runs.

So the substring spans:

[left_start ... s]
    + (z zeros in middle)
    + [e ... right_end]

5. For each start s, how many valid end positions?

The substring must satisfy:

end - start + 1 â‰¥ Lmin = zÂ² + z
end â‰¥ start + Lmin - 1


Given end can go up to right_end, the number of valid end choices is:

count = right_end - (start + Lmin - 1) + 1


This decreases linearly as start increases, which forms an arithmetic sequence.

6. Split into two regions

To avoid iterating over every possible (start, end), we split:

Region A:

Starts where all end positions are valid.

Region B:

Starts where only some ends are valid (linearly decreasing count).

Using math, both regions are summed in O(1) time each.

Thus each block of z zeros is processed in constant time.

7. Why only up to 200 zeros?

When z gets large:

Lmin = zÂ² + z grows very fast


Beyond z â‰ˆ 200, Lmin becomes so large that no substring can be long enough to satisfy the condition (string is too short).

So only:

z â‰¤ 200


are needed, making the solution fast.

âœ… Time Complexity
1. Preprocessing zero positions: O(n)
2. Counting all-ones substrings: O(m)

(where m is number of zeros)

3. Main loop for z zeros:

For each z from 1 to 200:

iterate over all groups of z zeros: at most m

each processed in O(1)

So upper bound:

O(200 * n) = O(n)


Thus:

ğŸ‘‰ Final Time Complexity: O(n)

(for n up to 2e5 comfortably)

ğŸ“¦ Space Complexity

We store:

the list of zero positions: O(m) â‰¤ O(n)

So:

ğŸ‘‰ Final Space Complexity: O(n)
ğŸ¯ Summary of the Intuition

Convert the problem from free indices to blocks of zeros and the ones gaps around them.

All-ones substrings are counted trivially.

For each block with z zeros, derive the minimum length condition.

Use arithmetic progression math to count valid (start, end) pairs in O(1).

Limit z to â‰¤ 200 because requirement grows quadratically.

This transforms an otherwise impossible O(nÂ²) brute force into a clean O(n) solution.
